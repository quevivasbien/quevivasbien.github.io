import{S as A,i as L,s as R,k as u,q as l,a as I,l as c,m as g,r as m,h as t,c as k,n as J,b as i,H as o,C as E}from"../chunks/index.d8bf866d.js";function W(Y){let s,x,d,h,_,w,f,M,b,p,S,v,r,T,n,q,j;return{c(){s=u("h1"),x=l("Yet another Mandelbrot explorer"),d=I(),h=u("p"),_=l("I’ve made quite a few attempts at creating a visualizer for the Mandelbrot set. This has become something of a go-to project for me when learning a new programming language and has been a not-insignificant factor in motivating me to learn some new technologies."),w=I(),f=u("p"),M=l("I have made a few iterations on explorers making use of WebAssembly, starting with a dreadfully slow attempt using C++‘s emscripten compiler, and culminating in a Rust-based version I made a few months back. Most of these iterations suffered from rendering artifacts due to off-by-one errors in delegating calculations to web workers, collecting the results, and stitching them together on the HTML canvas. I finally got around to fixing those artifacts and now have a version of the Mandelbrot explorer that I feel quite happy with (though, of course, I already have in mind more improvements)."),b=I(),p=u("p"),S=l("I ended up using plain JavaScript (no TypeScript and no web framework) for this, just because importing the wasm inside workers was giving me headaches otherwise. (I’m probably missing something, but as far as I can tell it is currently impossible to import scripts within a web worker in TypeScript, or at least this is still an experimental feature in some major browsers. This seems bizarre to me, but it is generally in line with JS’s general lack of support for multiprocessing features.)"),v=I(),r=u("p"),T=l("You can check out the result "),n=u("a"),q=l("here"),j=l("."),this.h()},l(e){s=c(e,"H1",{});var a=g(s);x=m(a,"Yet another Mandelbrot explorer"),a.forEach(t),d=k(e),h=c(e,"P",{});var P=g(h);_=m(P,"I’ve made quite a few attempts at creating a visualizer for the Mandelbrot set. This has become something of a go-to project for me when learning a new programming language and has been a not-insignificant factor in motivating me to learn some new technologies."),P.forEach(t),w=k(e),f=c(e,"P",{});var z=g(f);M=m(z,"I have made a few iterations on explorers making use of WebAssembly, starting with a dreadfully slow attempt using C++‘s emscripten compiler, and culminating in a Rust-based version I made a few months back. Most of these iterations suffered from rendering artifacts due to off-by-one errors in delegating calculations to web workers, collecting the results, and stitching them together on the HTML canvas. I finally got around to fixing those artifacts and now have a version of the Mandelbrot explorer that I feel quite happy with (though, of course, I already have in mind more improvements)."),z.forEach(t),b=k(e),p=c(e,"P",{});var C=g(p);S=m(C,"I ended up using plain JavaScript (no TypeScript and no web framework) for this, just because importing the wasm inside workers was giving me headaches otherwise. (I’m probably missing something, but as far as I can tell it is currently impossible to import scripts within a web worker in TypeScript, or at least this is still an experimental feature in some major browsers. This seems bizarre to me, but it is generally in line with JS’s general lack of support for multiprocessing features.)"),C.forEach(t),v=k(e),r=c(e,"P",{});var y=g(r);T=m(y,"You can check out the result "),n=c(y,"A",{href:!0,rel:!0});var H=g(n);q=m(H,"here"),H.forEach(t),j=m(y,"."),y.forEach(t),this.h()},h(){J(n,"href","https://quevivasbien.github.io/mandelbrot-wasm/"),J(n,"rel","nofollow")},m(e,a){i(e,s,a),o(s,x),i(e,d,a),i(e,h,a),o(h,_),i(e,w,a),i(e,f,a),o(f,M),i(e,b,a),i(e,p,a),o(p,S),i(e,v,a),i(e,r,a),o(r,T),o(r,n),o(n,q),o(r,j)},p:E,i:E,o:E,d(e){e&&t(s),e&&t(d),e&&t(h),e&&t(w),e&&t(f),e&&t(b),e&&t(p),e&&t(v),e&&t(r)}}}class D extends A{constructor(s){super(),L(this,s,null,W,R,{})}}export{D as default};
